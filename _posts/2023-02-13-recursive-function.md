---
layout: post
title:  "재귀"
date:   2023-02-13
author: hyobbeee
categories: JavaScript
tags: TIL JavaScript
cover:  "/assets/instacode.png"
---
- GOAL
    - 재귀의 의미
    - 탈출 조건 이해
    - base case와 recursive case로 나눠 작성 가능

### 📍재귀란

원래 자리로 되돌아가거나, 되돌아옴.

```jsx
function recursion () {
  console.log("This is")
  console.log("recursion!")
  recursion()
}
```

### 📍재귀 예제

`문제: 자연수로 이루어진 리스트(배열)를 입력받고, 리스트의 합을 리턴하는 함수 `arrSum` 을 작성하세요.`

```jsx
function arrSum (arr) {
	// 빈 배열을 받았을 때 0을 리턴하는 조건문
	// --> 가장 작은 문제를 해결하는 코드 & 재귀를 멈추는 코드
	if (arr.length === 0) return 0;

	// 배열의 첫 요소 + 나머지 요소가 담긴 배열을 받는 arrSum 함수
	// --> 재귀(자기 자신 호출)를 통해 문제를 작게 쪼개나가는 코드
	return arr.shift() + arrSum(arr);
}
```

### 📍언제 사용하는지

1. 주어진 문제를 비슷한 구조의 더 작은 문제로 나눌 수 있는 경우
2. 중첩된 반복문이 많거나 반복문의 중첩 횟수(number of loops)를 예측하기 어려운 경우
    
    ```jsx
    for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
            for (let k = 0; k < n; k++) {
                for (let l = 0; l < n; l++) {
                    for (let m = 0; m < n; m++) {
                        for (let n = 0; n < n; n++) {
                            for (let o = 0; o < n; o++) {
                                for (let p = 0; p < n; p++) {
                                    // do something
                                    someFunc(i, j, k, l, m, n, o, p);
                               }
                            }
                        }
                    }
                }
            }
        }
     }
    ```
    

모든 재귀함수는 반복문으로 표현할 수 있다. 그러나 재귀를 적용할 수 있는 대부분의 경우는, 재귀를 적용한 코드가 더욱 간결하고 이해하기 쉽다.

### 📍재귀의 기초

문제를 여러 경우로 구분한 다음에, 가장 해결하기 쉬운 문제부터 해결하는 것

재귀함수 구현시, 재귀의 탈출 조건(재귀 호출 멈추는 조건)을 구성한다.

탈출 조건이 없으면 무한루프에 빠지게됨 → 문제를 최대한 작게 쪼갠 후 탈출 조건을 세우는 것이 중요

ex) `arrSum` 을 더이상 쪼갤 수 없는 경우는 입력값이 빈 배열일 경우이고, 이때 `arrSum([])` 의 리턴 값은 0이다.

- `arrSum: [number] => number`
- `arrSum([ ]) === 0` ← 입력값이 빈 배열인 경우 : 해결!
- `arrSum([요소1, 요소2, ... , 요소n])`

### 📍사용법

<aside>
💡 세줄요약
1. 문제를 동일한 방식으로 쪼개기 (recursive case)
2. 더이상 안쪼개지면 탈출조건임 (base case)
3. base case 해결하기 → 쪼갠 문제 한번에 해결

</aside>

1. **재귀 함수의 입력값과 출력값 정의하기**
    
    함수의 입출력값을 정의하는 것은 그 첫 출발점이다.
    
    재귀적으로 사고하는 데 가장 먼저 해야할 일은 문제를 가장 추상적으로 또는, 가장 단순하게 정의하는 것이다. 
    
    ex) 함수 `arrSum` 의 경우 `number` 타입을 요소로 갖는 배열을 입력으로 받고, `number` 타입을 리턴한다. 이를 좀 더 간단하게 표기하면 다음과 같다.
    
    ```jsx
    arrSum: [number] => number // 입출력 값 정의
    ```
    
2. **문제를 쪼개고 경우의 수를 나누기**
    
    문제를 쪼갤 기준을 정하고, 정한 기준에 따라 문제를 더 큰 경우와 작은 경우로 구분할 수 있는지 확인한다.
    
    일반적으로, **입력값이나 문제의 순서와 크기**를 기준으로 정한다.
    
    주어진 입력값 또는 문제 상황을 크기로 구분할 수 있거나, 순서를 명확하게 정할 수 있다면 문제를 구분하는데 도움이 된다. 그리고 구분된 문제를 푸는 방식이 순서나 크기와 관계없이 모두 같다면, 문제를 제대로 구분한 것이다.
    
    - 함수 `arrSum` 은 입력값이 빈 배열인 경우와 그렇지 않은 경우로 나눌 수 있다. 각각의 경우는 다른 방식으로 처리해야 한다.
        - `arrSum: [number] => numer`
        - `arrSum([ ])` ← 입력값이 빈 배열인 경우
        - `arrSum([요소1, 요소2, ... , 요소n])` ← 그렇지 않은 경우
3. **단순한 문제 해결하기 - 재귀의 기초(base case)**
    
    문제를 여러 경우로 구분한 다음에는, 가장 해결하기 쉬운문제부터 해결한다.
    
    재귀의 기초는 나중에 재귀함수를 구현할 때, 재귀의 탈출 조건을 구성한다.
    
    탈출 조건이 없는 경우 재귀함수는 끝없이 자기 자신을 호출한다. 그렇다고 문제를 덜 쪼갠 상태로 탈출 조건을 세우는 경우 문제를 제대로 해결할 수 없다. 그만큼 문제를 최대한 작게 쪼갠 후 문제를 해결하는 것이 좋다.
    
    - 함수 `arrSum` 을 더이상 쪼갤 수 없는 경우는 입력값이 빈 배열일 경우이고, 이때 `arrSum([])` 의 리턴값은 0이다.
        - `arrSum: [number] => number`
        - `arrSum([ ]) === 0` ← 입력값이 빈 배열인 경우 : 해결!
        - `arrSum([요소1, 요소2, ... , 요소n])`
4. **복잡한 문제 해결하기**
    
    남아있는 복잡한 경우를 해결한다.
    
    - 길이가 1이상인 배열이 함수 `arrSum` 에 입력된 경우, 입력된 배열을 배열의 첫 요소와 나머지 요소를 입력값으로 갖는 문제로 쪼개고, 둘을 더한다.
    - `arrSum: [number] => number`
    - `arrSum([ ]) === 0`
    - `arrSum([요소1, 요소2, ... , 요소n]) === 요소1 + arrSum([요소2, ..., 요소n])` ← 그렇지 않은 경우 : 해결!
    - 배열을 첫 요소와 더 작은 문제로 쪼개는 방법만 안다면, 함수 `arrSum` 을 재귀적으로 구현할 수 있습니다.
5. **코드로 구현**
    
    ```jsx
    function arrSum(arr) {
    	// base case : 문제를 더이상 쪼갤 수 없는 경우(재귀의 기초)
    	if (arr.length === 0) return 0;
    
    	// recursive case : 그렇지 않은 경우
    	return 요소1 + arrSum([요소2, ... , 요소n]);
    }
    ```
    

> cf. 일반적인 재귀 함수 탬플릿
> 

```jsx
function recursive(input1, input2, ...) {
  // base case : 문제를 더 이상 쪼갤 수 없는 경우
  if (문제를 더 이상 쪼갤 수 없을 경우) {
    return 단순한 문제의 해답;
  }

  // recursive case : 그렇지 않은 경우
  return 더 작은 문제로 새롭게 정의된 문제
}
```