---
layout: post
title:  "시간복잡도"
date:   2023-02-16
author: hyobbeee
categories: JavaScript
tags: TIL JavaScript
cover:  "/assets/instacode.png"
---
## 📍개념

<aside>
💡 입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?
</aside>
<br>
효율적인 알고리즘을 구현한다는 것은 바꿔 말해 **입력값이 커짐에 따라 증가하는 시간의 비율을 최소화한 알고리즘을 구성했다**는 얘기다.

## 📍특징

- 시간 복잡도는 주로 빅-오 표기법을 사용해 나타내는데, 최악의 경우를 고려하므로 프로그램이 실행되는 과정에서 소요되는 최악의 시간까지 고려할 수 있기 떄문이다.
- “최소한 특정 시간 이상이 걸린다” 혹은 “이 정도 시간이 걸린다”를 고려하는 것보다 “이 정도 시간까지 걸릴 수 있다”를 고려해야 그에 맞는 대응이 가능하다.
    
    → 최댓값 보다 최소값과 중간값을 구해 기대치를 낮추기 작전
    

## 📍시간 복잡도를 표기하는 방법

- Big-O(빅-오) → 상한 점근
- Big-Ω(빅-오메가) → 하한 점근
- BIg-θ(빅-세타) → 그 둘의 평균

### 👉🏻시간 복잡도 최선의 경우

결과를 반환하는데 최선의 경우 1초, 평균적으로 1분, 최악의 경우 1시간이 걸리는 알고리즘을 구현했고, 최선의 경우를 고려한다고 가정하면, 최선의 경우 100초가 걸린다.

만약 실제로 걸린 시간이 1시간을 훌쩍 넘겼다면, ‘**어디에서 문제가 발생한거지?**’ 란 의문이 생긴다.

최선의 경우만 고려하였으니, 어디에서 문제가 발생했는지 알아내기 위해서는 로직의 많은 부분을 파악해야 하므로 문제를 파악하는데 많은 시간이 필요하다.

### 👉🏻시간 복잡도 중간의 경우

알고리즘을 100번 실행할 때 100분의 시간이 소요된다고 생각했는데, 최악의 경우가 몇 개 발생하여 300분이 넘게 걸렸다면 최선의 경우를 고려한 것과 같은 고민을 하게 된다.

### 👉🏻시간 복잡도 최악의 경우

극단 적인 예이지만 위와 같이 최악의 경우가 발생하지 않기를 바라며 시간을 계산하는 것보다는 ‘최악의 경우도 고려하여 대비’하는 것이 바람직하다.

따라서 다른 표기법보다 Big-O 표기법을 많이 사용한다.

다시한번 Big-O 표기법이란 ‘입력값의 변화에 따라 연산을 실행할 때, 연산 횟수에 비해 시간이 얼마만큼 걸리는가?’ 를 표기하는 방법이다.

## 📍Big-O 표기법 종류

1. O(1)
2. O(n)
3. O(log n)
4. O(n^2)
5. O(2^n)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/da4c40d6-6d49-4229-9fd5-5ccf03a90be6/Untitled.png)

### 1. O(1)

일정한 복잡도(constant complexity)라고 하며, 입력값이 증가하더라도 시간이 늘어나지 않는다. 
→ 다시말해 입력값의 크기와 관계없이, 즉시 출력값을 얻어낼 수 있다는 의미이다.

```jsx
function O_1_algorithm(arr, index) {
	return arr[index];
}

let arr = [1,2,3,4,5];
let idx = 1;
let result = O_1_algorithm(arr, idx);

console.log(result) = 2;
```

- 입력값의 크기가 아무리 커져도 즉시 입력값을 얻어낼 수있다.
- 예를 들어 arr의 길이가 100만이라도, 즉시 해당 index에 접근해 값을 반환할 수 있다.

### 2. O(n)

O(n)은 선형 복잡도(linear complexity)라고 부르며, 입력값이 증가함에 따라 시간 또한 **같은 비율**로 증가하는 것

→ 예를 들어 입력값이 1일때 1초의 시간이 걸리고, 입력값을 100배로 증가시켰을 때 1초의 100배인 100초가 걸리는 알고리즘을 구현한 경우다.

```jsx
function O_n_algorithm(n) {
	for (let i = 0; i < n; i++) {
		// do something for 1 sec
	}
}

function another_O_n_algorithm(n) {
	for (let i = 0; i < 2n; i++) {
		// do something for 1 sec
	}
}
```

- `O_n_algorithm`에선 입력값(n)이 1 증가할 때마다 코드의 실행시간이 1초씩 증가한다.
- 즉 입력값이 증가함에 따라 같은 비율로 걸리는 시간이 늘어나고 있다.
- `another_O_n_algorithm` 에서는 입력값이 1 증가할 때마다 코드의 실행이 2초씩 증가한다.
- 이 경우 O(2n)이라고 표현한다.
- 그러나, 사실 이 알고리즘 또한 Big-O 표기법으로는 O(n) 으로 표기한다.
- 입력값이 커지면 커질수록 계수(n 앞에 있는 수)의 의미가 점점 퇴색되기 때문에, 같은 비율로 증가하고 있다면 2배가 아닌 5배, 10배로 증가하더라도 O(n)으로 표기한다.

### 3. O(log n)

로그 복잡도(logarithmic complexity)라고 부르며, Big-O 표기법중 O(1) 다음으로 빠른 시간 복잡도를 가진다.

- 자료구조에서 배운 BST(Binary Search Tree)를 기억하는가? (아니요;;;)
- BST에서 원하는 값을 탐색할 때, 노드를 이동할 때마다 경우의 수가 절반으로 줄어든다.
- 예시로 up&down 게임에서 1~100 중 숫자를 고른다고 가정할 경우 매번 경우의 수가 절반으로 줄어들기 때문에 최악의 경우에도 7번이면 원하는 숫자를 찾아 낼 수 있게 된다.
- BST의 값 탐색 또한 이와 같은 로직으로, O(log n)의 시간복잡도를 가진 알고리즘(탐색기법)이다.

### 4. O(n^2)

2차 복잡도(quadratic complexity)라고 부르며, 입력값이 증가함에 따라 시간이 n의 제곱수의 비율로 증가하는 것을 의미한다.

- 예를 들어 입력값이 1일 경우 1초가 걸리던 알고리즘에 5를 주었을때 25초가 걸리게 되는 경우를 말한다.

```jsx
function O_quadratic_algorithm(n) {
	for (let i = 0; i < n; i++) {
		for (let j = 0; j < n; j++) {
			// do something for 1 sec
		}
	}
}

function another_O_quadratic_algorithm(n) {
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      for (let k = 0; k < n; k++) {
        // do something for 1 sec
      }
    }
  }
}
```

- 2n, 5n을 모두 O(n)이라고 표기하는 것처럼, n3과 n5도 모두 O(n2)로 표기한다.
- n이 커지면 커질술고 지수가 주는 영향력이 점점 퇴색되기 때문에 이렇게 표기한다.

### 5. O(2^n)

기하급수적 복잡도(exponential complexity)라고 부르며, Big-O 표기법 중 가장 느린 시간 복잡도를 가진다.

- 종이를 42번 접으면 그 두께가 지구에서 달까지의 거리보다 커진다는 이야기를 들어본적 있나요? (아니요..)
- 매번 접힐 때마다 두께가 2배로 늘어나기 때문인데
- 구현한 알고리즘의 시간복잡도가 O(2n)이라면 다른 접근방식을 고민해보는 것이 좋다.

```jsx
function fibonacci(n) {
	if (n <= 1) {
		return 1;
	}
	return fibonacci(n - 1) + fibonacci(n - 2);
}
```

피보나치 수열은 O(2n)의 시간복잡도를 가진 대표적인 알고리즘이다.

브라우저 개발자 창에서 n을 40으로 두어도 수초가 걸리는 것을 확인 할 수 있으며, n이 100 이상이면 평생 결과를 반환하지 못할 수 도 있다.