---
layout: post
title:  "graph & tree"
date:   2023-03-15
tags: TIL web
author: hyobbeee
categories: web
cover:  "/assets/instacode.png"
---

## 렌더링이란

HTML, CSS, JavaScript 등 개발자가 작성한 문서를 브라우저에서 그래픽 형태로 출력하는 과정을 말한다. 

웹 개발을 하며 브라우저의 렌더링을 정확하고 이해하고 있으면 어떻게 개발을 해야 좋은 성능을 내는지, 성능 최적화를 어떻게 해야 하는지 정확히 판단하기 위해 정리해 보았다.

# HTML

---

## 📍구조

![브라우저의 구조 도식화](/assets/browser-rendering/Untitled.png)

브라우저의 구조 도식화

## 📍사용자 인터페이스(User Interface)

: 가장 유저와 밀접하게 맞닿아 있는 부분

주소, 표시줄, 이전/다음 버튼, 북마크 메뉴 등에 관련된 UI 부분을 통칭

## 📍브라우저 엔진

: 사용자 인터페이스와 렌더링 엔진 사이의 동작을 제어(control)하는 역할

HTML 문서와 기타 자원의 웹페이지를 사용자의 장치에 시각 표현으로 변환 → **문서 객체 모델(DOM) 자료구조를 구현**

- 웹 브라우저 마다 전용 엔진이 다름

| 이름 | 설명 |
| --- | --- |
| 게코(Gecko) | 모질라 재단에서 만든 브라우저 엔진.파이어폭스가 해당 엔진을 탑재하고 있는 유명한 웹 브라우저입니다. |
| 웹킷(Webkit) | KHTML에서 파생된 브라우저 엔진.사파리가 해당 엔진을 탑재하고 있는 가장 유명한 웹 브라우저입니다. |
| 블링크(Blink) | 웹킷(Webkit)에서 파생된 브라우저 엔진.크롬, 오페라가 해당 엔진을 탑재하고 있는 유명한 웹 브라우저입니다. |
| 트라이던트(Trident) | 마이크로소프트의 브라우저 엔진. 인터넷 익스플로러, 아웃룩 익스프레스, 마이크로소프트 아웃룩 등이 이를 탑재하고 있습니다. |
| 엣지HTML(EdgeHTML) | 트라이던트(Trident)에서 파생된 브라우저 엔진.마이크로소프트 엣지 스파르탄 버전(~2019)까지 탑재되었습니다. (현재는 블링크로 교체.) |

## 📍렌더링 엔진

: 요청한 컨텐츠 화면에 출력하는 역할

HTML 및 XML 문서와 이미지 표시 가능(플러그인이나 브라우저 확장 기능을 통해 다른 유형도 표시 가능)

## 📍통신(Networking)

: HTTP 요청과 같은 네트워크 호출시 사용

## 📍자바스크립트 해석기(JavaScript Interpreter)

: 웹 인터렉션에 사용됨

이외의 엔진

| 이름 | 설명 |
| --- | --- |
| Rhino | 모질라 재단이 운영하는 오픈소스 엔진으로, 자바(Java)로 개발되었다는 특징이 있습니다. |
| SpiderMonkey | 최초의 Javascript 엔진으로 넷스케이프 내비게이터를 지원하였으며, 현재는 파이어폭스를 지원하고 있습니다. |
| V8 | 구글이 개발한 오픈 소스 엔진으로 구글 크롬의 Javascript 엔진입니다. |
| JavascriptCore | 애플에서 개발하였으며 처음에 WebKit 프레임워크를 위해 개발되었지만 현재는 사파리와 React Native App를 지원하고 있습니다. |
| Chakra | 마이크로소프트가 개발한 엔진이며, Edge 브라우저를 지원하고 있습니다. |

![구글 크롬 V8엔진의 메모리 구조](/assets/browser-rendering/Untitled%201.png)

구글 크롬 V8엔진의 메모리 구조

### 힙 메모리(Heap Memory)

: 동적 메모리 할당에 사용되는 자료 구조

V8 엔진 내부에서 가장 큰 공간 차지

객체 또는 동적 데이터 저장 및 가비지 컬렉션 발생하는 곳

### 콜 스택(Call Stack)

: 프로그램상 우리가 어디에 있는지 기록하는 자료구조 

- 자바스크립트는 기본적으로 싱글 스레드 기반의 언어 → 콜스택 하나라는 뜻 → 한번에 한 작업만 가능
- 후입선출(LIFO)의 구조 → 함수 실행 후 콜스택 가장 상단에 있기 때문에 바로 제거 가능
- 동작 방식
    
    ![실행 전 상태](/assets/browser-rendering/Untitled%202.png)
    
    실행 전 상태
    
    1. `printSquare(4)` 호출 → 함수가 스택으로 push
    2. `square(n)` 호출 → 함수가 스택으로 push
    3. `multiply(n, n)` 호출 → return 문만 호출(특정 값이 없기 때문에 쌓이기만 함)
    4. `return a * b;` 값 획득 → 스택에서 pop
    5. 함수 `multiply` 와 함수 `square` 차례대로 return 값 획득 → 스택에서 pop 
    6. `printSquare` 함수 내부에 `console.log(squared)` 가 있으므로 스택에 push → 실행 → pop
    
    → 여기서 콜 스택에 쌓이는 데이터를 스택 프레임(stack frame)이라고 부름
    
- **Stack Overflow** (한정된 메모리 공간 넘을시 발생하는 에러) → 콜스택은 힙과 달리 자료구조 자체가 크기 제한이 있음

### 스택 오버플로우(Stack Overflow)

: 콜 스택 내부의 동일한 스택 프레임이 예상치 못한 수로 쌓일 때 발생하는 에러

### 스택 추적(Stack trace)

: 에러 로그를 확인해보면 어디서 에러가 발생하고, 에러의 결과가 무엇인지 확인 가능

![Untitled](/assets/browser-rendering/Untitled%203.png)

## 📍UI 백엔드

: 렌더링 엔진이 분석한 Render Tree를 브라우저에 그리는 역할

Select, Input 창과 같은 기본적인 위젯을 그려줌

플랫폼에 명시하지 않은 일반적인 인터페이스로, OS 사용자 인터페이스 체계를 사용

![맥의 터미널, 윈도우의 명령 프롬프트](/assets/browser-rendering/Untitled%204.png)

맥의 터미널, 윈도우의 명령 프롬프트

### **명령어 라인 인터페이스**, CLI(Command Line Interface)

: 이런 종류의 인터페이스를 다룰 때는 특정한 명령 체계를 사용하는 것

### 일괄 처리 인터페이스(Batch Interface)

: 사용자가 배치 처리에 앞서 모든 세부 사항을 저장하고, 모든 처리가 완료되면 출력을 수신하는 비대화형 사용자 인터페이스

- 대규모의 시스템에서 대량의 데이터를 처리하는 데 유용

![그래픽 사용자 인터페이스](/assets/browser-rendering/Untitled%205.png)

그래픽 사용자 인터페이스

### 그래픽 사용자 인터페이스(GUI)

: 보통 마우스, 키보드, 모니터 등을 이용해 아이콘을 클릭하거나 직관적인 입력이 가능한 인터페이스

## 📍자료 저장소

: 말그대로 자료를 저장하는 계층

- 쿠키를 저장하는 것 같이 모든 자원을 하드 디스크에 저장할 필요가 있어 필요함
- HTML5 명세에는 브라우저가 지원하는 웹 저장소(Web Stroage)는 스펙이 정의 되어있다.
- 영구적인 저장소인 **로컬 스토리지**와 임시적 저장소인 **세션 스토리지**를 따로 두어 데이터의 지속성을 구분 할수 있어 선택적 사용 가능

# 웹 스토리지

---

## 📍웹 스토리지

### 특징

- HTML5 이전에는 쿠키에 정보를 저장했었음(보안성 취약, 저장소 용량 작음) → 웹 스토리지 등장
- 웹 브라우저가 직접 데이터를 저장 가능
- 사용자 측에서 더 많은 양의 정보를 안전하게 저장 가능
- 저장 데이터 클라이언트에게만 존재 → 네트워크 트래픽 비용 감소
- 오리진(origin)마다 하나씩만 존재
- 오리진이란?
    - 도메인과 프로토콜 한쌍으로 이뤄진 식별자
    - 하나의 오리진에 속하는 모든 웹페이지는 같은 데이터를 저장하기 때문에 같은 데이터에 접근할 수 있음

### 종류

1. 로컬 스토리지(localStorage)
    - 로컬 스토리지 객체는 보관 기한이 없는 데이터를 저장 → 컴퓨터 재부팅시 사라지지 않음
    - Windows전역 객체의 localStroage라는 컬렉션을 통해 저장 조회 가능
    - 도메인마다 별도 localStorage 생성 → 도메인만 같으면 전역으로 데이터 공유 가능
2. 세션 스토리지(sessionStorage)
    - 세션 스토리지 객체는 하나의 세션만을 위한 데이터를 저장
    - 데이터 지속적으로 보관 x → 사용자가 브라우저 탭이나 창을 닫으면 데이터 소멸
    - 브라우징이란?
        - 브라우저 프로그램을 실행해서 인터넷에 들어가 필요한 정보를 찾는 행위
    - 브라우저 컨텍스트란?
        - 브라우저가 문서를 표시하는 환경
        - 각 브라우징 컨텍스트는 특정 출처 및 활성화되고 있는 문서의 출처, 표시했던 모든 문서의 방문기록을 갖고 있음
    - 저장과 조회는 Windows 전역 객체의 sessionStorage라는 컬렉션을 통해 이뤄짐 + 도메인 별도 생성
    
    <aside>
    ⚠️ 브라우저 컨텍스트가 다르면 서로 다른 영역이 됨 → 브라우저 두개 열어도 데이터 공유 불가
    
    </aside>
    

### 기능

브라우저 컨텍스트 내에서 저장한 데이터를 가지고 활용 가능

→ 복구 및 백업에 관련된 기능 주로 사용

```jsx
e.g.
- 블로그 글을 작성하다가 사용자가 창을 벗어난 경우 관련 작성 내용을 복구하거나 백업해주는 기능
- 사용자가 입력 form을 통해 정보를 입력하다 페이지에서 벗어난 경우 복구 및 백업해주는 기능
- 현재 읽은 글의 히스토리 저장(카운팅, 혹은 읽은 글 표시 등으로 활용)
```

# 브라우저 렌더링

---

HTML, CSS, JavaScript 등 개발자가 작성한 문서가 브라우저에서 출력되는 과정

## 과정

![Untitled](/assets/browser-rendering/Untitled%206.png)

1. 사용자 브라우저 통해 웹사이트 접속
2. 브라우저 : 서버로부터 필요한 리소스 다운
3. 렌더링 엔진 : 전달받은 HTML문서를 파싱(parsing)해 DOM(Document Object Model) 트리를 생성
4. 이어서 다운받은 외부 CSS 파일과 함께 포함된 스타일 요소를 파싱 CSSOM(Object Model) 트리를 생성
5. 만든 DOM 트리와 CSSOM 트리를 결합 → 렌더 트리 구축
6. 레이아웃 과정을 통해 각 요소 배치
7. paint : UI 백엔드에서 렌더 트리를 화면에 그림

### 파싱이란

: 프로그래밍 언어로 작성된 파일을 실행시키기 위해 구문 분석(syntax analysis)을 하는 단계

이런 파싱을 파서(parser)가 진행한다.

<aside>
💡 **파서(parser)**
- 일종의 인터프리터나 컴파일러 구성 요소 가운데 하나
- HTML 파일의 코드를 토큰(문법적 의미를 갖는 최소 단위)으로 분해 → 이 토큰들을 문법적 의미와 구조에 따라 노드(node)라는 요소로 바꿈
- 노드들은 상하 관계에 따라 하나의 트리를 형성 → 파스 트리, 문법 트리

</aside>

### 문서 파싱(document parsing)

: 브라우저가 코드를 이해하고 사용할 수 있는 구조로 변환하는 것

렌더링 과정에서는 HTML 파일을 바탕으로 DOM트리를 구축, CSS 파일로 CSSOM 트리를 만드는 것을 말함

### 브라우저 렌더링 과정

1. 브라우저는 HTML 문서를 받아 들자마자 DOM 트리로 파싱 실행 
2. 이때 HTML 토큰이 만들어지는데, 이 토큰에는 시작 태그와 마침 태그, 속성과 이름과 값도 포함됨
3. 이런 토큰으로 변한 입력값은 파서에 의해 노드가 됨

- CSS 스타일을 만날 경우 : 텍스트를 CSS스타일링 레이아웃과 페인팅에 사용하는 데이터 구조인 CSSOM 트리로 파싱
- `<script>` 태그를 만날 경우 : 렌더링을 차단하면서 HTML 파싱 또한 중단 → 태그 내 `src` 속성으로 연결된 파일을 다운받아 파싱하고 실행시킴 → 다시 HTML파일을 파싱

<aside>
⚠️ 파싱은 문서에 작성된 언어 또는 형식의 규칙에 따른는데 파싱할 수 있는 모든 형식은 정해진 용어와 구문 규칙을 따라야 함 → 형식을 잘 갖춘 문서라면 파싱 과정은 직관적이고 빠르게 진행됨

</aside>

## 📍DOM Tree

**DOM(Document Object Model)** 

: HTML 문서의 요소들의 중첩 관계를 기반으로 노드들을 트리 구조로 구성한 것

브라우저는 JavaScript 언어만 알아 듣기 때문에 HTM의 태그나 속성들을 이해하지 못함

응답으로 받아온 HTML문서는 텍스트로만 이뤄져 있음 → 그래서 이해할 수 있도록 객체로 바꿔준 것

![Untitled](/assets/browser-rendering/Untitled%207.png)

## 📍CSSOM Tree

html 파일을 DOM 트리로 파싱하던 브라우저는 `<link>`, `<style>` 태그를 만나게 되면 파싱을 잠시 멈추고 해당 리소스 파일을 서버로 요청

CSSOM(CSS Object Model, 파일을 파싱해 만든 트리) 트리를 구축하고 나면 브라우저는 다시 html 파일의 파싱을 멈췄던 부분으로 돌아가서 마저 DOM 트리를 구축

![Untitled](/assets/browser-rendering/Untitled%208.png)

<aside>
⚠️ **CSS는 부모의 속성을 자식이 상속 받는다**
e.g. `body` 가 부모요소이고 `font-size` 가 16px인 속성을 갖고 있는데, 그 아래 `p` 는 자식 요소 이기 때문에 부모인 `body` 가 갖고 있던 속성을 상속 받으면서 동시에 자신이 가지고 있는 속성인 `font-weight` 속성 까지 갖게 되므로 2개의 속성을 갖게됨

</aside>

## 📍렌더 트리(Render Tree)

: 렌더 트리는 이름처럼 렌더링을 목적으로 만들어지는 트리

렌더링은 사용자에게 브라우저가 보여주고자 하는 화면을 그리는 과정이므로, 보이지 않을 요소들은 이 트리에 포함시키지 않는다.

DOM트리와 ≠ CSSOM트리 : 애초에 리소스부터 틀린 서로 다른 속성을 가진 독립적인 트리이므로, 브라우저 위에 웹사이트를 표시하기 위해서는 이 둘을 합치는 작업이 반드시 필요

![결국 사용자의 눈에 보여야 하는 것만 렌더하기 때문에 보이지 않아야 하는 요소나 태그는 제외](/assets/browser-rendering/Untitled%209.png)

결국 사용자의 눈에 보여야 하는 것만 렌더하기 때문에 보이지 않아야 하는 요소나 태그는 제외

## 📍레이아웃

: 렌더트리를 기반으로 HTML 요소의 레이아웃(위치, 크기 등)을 계산하여 브라우저 화면 어디에 배치할지 결정하는 과정

위 그림에서도 볼 수 있듯이 DOM, CSSOM에 있던 속성들이 합쳐져 렌더트리를 구성하는 것을 볼 수 있다.

그러나 아직까지 렌더트리라는 텍스트로 구성된 객체만 보인다. 페인팅이라는 작업을 거쳐야지 브라우저 위의 화면으로 그려지게 된다.

 하지만 아직까지 이 정보들은 그저 각 요소에 관련된 정보일 뿐, 전체 화면에서 정확히 어디에 위치하는가에 대해서는 알지 못한다. → 이런 계산을 브라우저의 **렌더링 엔진**이 함.

### 렌더링 엔진

브라우저는 각 요소가 전체화면에서 어디에 어떤 크기로 어떻게 배치되어야 하는지 파악하기 위해 렌더트리를 위에서 아래로 읽어 내려간다. 그리고 모든 값은 절대적인 단위인 px값으로 변환

## 📍페인팅

각 정보를 가진 **픽셀**들이 모여 하나의 화면을 구성하는 과정

# 렌더링 최적화

---

## 📍리플로우(Layout)

: 어떤 웹 인터렉션으로 인해 앞서 보았던 렌더링 과정의 레이아웃을 반복해 수행하는 것

### e.g.

- 페이지 초기 렌더링 시
- 윈도우 리사이징 시(Viewport 크기 변경 시)
- 노드 추가 또는 제거 시
- 요소의 위치, 크기 변경 시(left, top, margin, padding, border, width, height 등)
- 폰트 변경과 이미지 크기 변경 시

## 📍리페인트(Repaint)

: 페인트 과정을 반복해 수행하는 것(리플로우만 수행되면 실제 화면에 반영 되지 않고, Render Tree를 다시 화면에 그려주는 과정 필요하기 때문)

하지만 무조건 리플로우가 일어나야 리페인트 되는 것은 아님 (background-color, visibility와 같이 레이아웃에 영향을 주지 않는 스타일 속성이 변경되었을 때는 리플로우 수행 x)

## 📍최적화하는 방법

### 불필요한 레이아웃 줄이기

- 사용하지 않는 노드에는 `visibility: invisible` 보다 `display: none` 을 사용
    - `visibility` 는 레이아웃 공간을 차지하기 때문에 reflow의 대상이기 때문

### layout, paint를 발생시키는 속성 피하기

- 리플로우가 일어나는 속성

| position | width |  height | left | top | right |
| --- | --- | --- | --- | --- | --- |
| bottom | margin |  padding | border | border-width | clear |
| display | float | font-family | font-size | font-weight | line-height |
| min-height | overflow | text-align | vertical-align |  ... |  |
- 리페인트가 일어나는 속성

| background | background-image |  background-position | background-repeat | background-size | border-radius |
| --- | --- | --- | --- | --- | --- |
| border-style | box-shadow |  color | line-style | outline | clear |
| display | float | font-family | font-size | font-weight | outline-color |
| visibility | ... |  |  |  |  |

### 영향 주는 노드 줄이기

JS + CSS를 조합한 애니메이션이 많거나, 레이아웃 변화가 많은 요소의 경우 `position` 을 `absolute` 또는 `fixed` 를 사용해주면 영향을 받는 노드 줄일 수 있음

---

230317 추가

## 🙆🏻‍♂️ 리액트의 Virtual DOM, Angular Change Detector는 왜 필요한가?

리액트나 앵귤러를 쓰면 웹페이지의 성능이 좋아진다고 들었다.

저 역시도 원리는 모르지만 리액트나 앵귤러가 순수하게 작성된 웹페이지보다 성능이 좋다고 빠르다고 알고 있었습니다. 이번 글을 정리하면서 원리가 무엇일까 궁금증이 들어 이를 해결하기 위해 간단히 정리해 보았습니다.

일반적으로 DOM에 접근하여 여러번의 속성 변화, 여러번의 스타일 변화를 수행하면 그에 따라 여러번의 Reflow, Repaint가 발생하게 된다.

하지만 Virtual DOM은 이렇게 변화가 일어나 Reflow, Repaint가 필요한 것들을 한번에 묶어서 DOM에 전달하게 된다. 

→ 처리되는 Reflow, Repaint의 규모가 커질 수는 있지만 한번만 연산을 수행하면 되기 때문 반복적으로 일어나는 부분이 줄어들어 성능 개선

물론 프레임워크 없이 순수한 JavaScript로 똑같은 알고리즘을 구현할 수 있겠지만 실제로 구현하기에는 매우 어렵기 때문에 리엑트, 앵귤러가 이를 대신해줘 인기를 얻었다고 생각한다.

최근 모던 웹브라우저는 성능이 매우 뛰어나므로 대부분의 경우 크게 성능 개선을 고려할 필요성을 느끼지 못함 but 프론트엔드 개발을 하다보면 다양하고 복잡한 요구사항에 대응하는 경우 많아지고 화면이 라이브 데이터에 따라 실시간으로, 빠르게 수많은 변경을 일으켜야하는 경우도 생기기 때문에 알아둬야 한다.