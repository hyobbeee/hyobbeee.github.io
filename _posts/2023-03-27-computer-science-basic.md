---
layout: post
title:  "컴퓨터 공학 기초"
date:   2023-03-27
tags: TIL CS
author: hyobbeee
categories: CS
cover:  "/assets/instacode.png"
---

# 0327 - 컴퓨터 공학(기초)

# 1. 컴퓨터 구조

---

- 컴퓨터는 단순하게 말하자면 하드웨어와 소프트웨어가 합쳐진 형태
- 하드웨어란 전자 회로 및 기계장치로 되어 있어 입출력 장치, 중앙처리장치(CPU), 기억장치 등으로 구성
- 소프트웨어는 그 하드웨어 위에서 하드웨어를 제어하며 작업을 수행하는 프로그램

# 1-1. 컴퓨터의 기본 구성 요소

---

입력장치(Input), 출력장치(Output)가 갖춰져 있고, 내부에서는 연산을 하기 위한 중앙처리장치(CPU), 저장하기 위한 주 기억장치와 보조 기억장치를 갖고 있다.

### 입력 장치

컴퓨터가 처리할 수 있는 형태로 데이터와 명령을 받아들이는 물리적인 장치

입력장치에는 다양한 물리적 장치가 존재하는데, 기본적으로 키보드와 마우스, 스캐너와 타블렛 등 컴퓨터에 연결하여 무언가를 입력할 수 있는 장치를 말함

### 출력 장치

처리된 데이터를 사람이 이해할 수 있는 형태로 출력하는 물리적인 장치

대표적으로 **모니터**가 있으며 모니터의 해상도는 화면에 나타나는 그림이나 글자의 선명도를 결정하는 요소인데 실제 화면의 해상도는 모니터와 그래픽 카드에 의해 결정된다.

그리고 프린터 또한 출력 장치에 들어가며 전자 장비에 저장되어 있는 문서를 종이 등에 인쇄하는 장치임

### 중앙처리 장치

CPU의 내부 구성은 크게 산술/논리 연산 장치(ALU)와 제어 장치, 레지스터로 구성되어 있다.

산술은 덧셈을 수행하는 것이고, 제어 장치는 프로그램에 따라 명령과 제어 신호를 생성하여 각종 장치의 동작을 제어하는 것이다.

그리고 **레지스터**는 CPU의 내부 메모리로서 CPU에서 사용하는 데이터를 일시적으로 저장하는 장소이다.

### 저장 장치

데이터나 프로그램을 보관하기 위한 일차 기억 장치인 주 기억장치(Memory)와 주 기억 장치를 보조하기 위한 디스크와 CD 같은 보조 기억 장치가 있다.

프로그램 수행을 위해 필요한 정보에 비해 중앙처리장치 내에 구비되어 있는 레지스터의 용량이 너무 작기 떄문에, 주 기억 장치는 주로 정보를 저장해 두었다가 필요할 때 읽어 들이는 저장소로 사용됨

주 기억 장치의 종류로는 RAM과 ROM이 존재한다.

그리고 보조 기억장치는 그런 주 기억장치를 보조하기 때문에 주 기억 장치에 비해 기억된 내용을 읽는 속도는 느리지만 대용량의 기억이 가능하며 현재 사용하지 않는 보조 프로그램은 보조 기억장치에 저장된다.

보조 기억 장치의 종류로는 플로피 디스크?와 하드 디스크 같은 자기 디스크가 존재하고, CD와 DVD 같은 광 디스크, 그리고 USB와 SSD 같은 플래쉬 메모리가 존재한다.

# 1-2-1. CPU

---

컴퓨터 시스템을 이루는 구성요소로 CPU, 주 기억장치인 메모리 그리고 보조 기억장치인 디스크와 씨디 등임을 앞서 학습했다.

여기 I/O(입출력장치)까지 추가 된다면 그것을 컴퓨터를 이루는 기본 골격이라고 할 수 있는데, 이것을 제안한 사람이 **폰 노이만**이다.

폰 노이만이 제안한 폰 노이만 구조는, 중앙처리장치(CPU)가 있고 이 중앙 처리 장치를 통해 연산을 수행하게 되는 구조이며 이 CPU는 각종 연산을 수행하고 기억장치에 기억되어 있는 명령어들을 수행하는 컴퓨터 시스템을 이루는 핵심 부품이다.

## 📍구조

CPU의 내부 구성은 크게 산술/논리 연산 장치(ALU), 제어 장치와 레지스터로 구성되어 있다.

- 산술 : 덧셈을 수행하는 것
- 제어 장치 : 시그널을 통해서 데이터 흐름을 통제하는 것
- 레지스터 : CPU 내부의 메모리

![CPU의 기본적인 구조](notion://www.notion.so/image/https%3A%2F%2Fs3-us-west-2.amazonaws.com%2Fsecure.notion-static.com%2Fc6d9b0ab-1264-43c4-8097-83d16501ad08%2FUntitled.png?id=93b42c8d-e785-460d-b893-1fc6d644239e&table=block&spaceId=7bbde794-b74d-442d-a5c4-37291104beab&width=1420&userId=207756fb-2b95-4231-af03-71010014c272&cache=v2)

CPU의 기본적인 구조

### 산술/논리 연산 장치(Arithmetic Logic Unit, ALU)

산술논리연산장치는 산술적인 연산과 논리적인 연산을 담당하는 장치 

가산기, 보수기, 누산기, 기억 레지스터, 데이터 레지스터 등으로 구성됨

캐시나 메모리부터 읽어 온 데이터는 레지스터(Register)라는 CPU 전용의 기억장소에 저장

레지스터에 저장된 데이터를 이용해 덧셈, 곱셈 등과 같은 산술 연산 수행

부동소숫연산장치(FPU), 정수연산장치, 논리연산(AND, OR 등)장치 등이 있다.

### 레지스터(Register)

중앙처리 장치(CPU) 내부에 있는 기억장치

주로 산술 연산 논리장치에 의해 사용되는 범용 레지스터(General-Purpose Register)와 PC 등 특수 목적에 사용되는 전용 레지스터(Dedicated-Purpose Register)로 구분

- 레지스터의 종류
    - IR(Instruction Register) : 현재 수행 중에 있는 명령어 부호를 저장하고 있는 레지스터
    - PC(Program Counter) : 명열어 저장된 메모리의 주소를 가리키는 레지스터
    - AC(Accumulator) : 산술 및 논리 연산의 결과를 임시로 기억하는 레지스터

### 제어장치(Control Unit, CU)

제어장치는  CPU가 자신 및 주변기기들을 컨트롤 하는 장치

- 구성
    - 프로그램 계수기(Program Counter) : 프로그램의 수행 순서를 제어
    - 명령 레지스터(instruction register) : 현재 수행중인 명령어의 내용을 임시 기억
    - 명령 해독기(instruction decoder) : 명령 레지스터에 수록된 명령을 해독하여 수행될 장치에 제어 신호를 전달
- 제어장치 구현 방식

| Hardwired(고정 배선 제어) | Micro Program |
| --- | --- |
| 제어신호가 Hardwired Circuit 에 의해서 생성 되도록 하드웨어 구성하며 상태계수기와 PLA(Programmable Logic Array ) 회로로 구성 | 발생 가능한 제어 신호들의 조합을 미리 구성하여 ROM 에 저장했다가 필요 시 신호를 발생시키는 Software 방식 |
| 고속 처리, 고가 | 하드웨어 방식에 비해 속도도 낮고 가격도 저렴 |
| RISC 시스템에 적용 | CISC 에 적용 |

## 📍기능

명령어와 데이터와 관련있다.

명령어 인출 및 해독은 모든 명령어들에 대하여 공통적으로 수행하며 기억 장치로부터 명령을 읽어 온다.

그리고 데이터 인출 및 처리, 쓰기와 같은 것들은 명령어에 따라 필요할 때만 수행

이 명령어 및 명령어 수행 과정과 처리 방식은 CPU에서 중요한 부분을 차지한다.

### 명령어

명령어는 시스템 특정 동작을 수행시키는 작은 단위

- 동작 코드(Op-code): 각 명령어의 실행 동작을 구분하여 표현
- 오퍼랜드(Operand): 명령어의 실행에 필요한 자료나 실제 자료의 저장 위치를 의미

### 명령어 수행 과정

![Untitled](https://www.notion.so/hyobbeee/0327-58be517d1348477bbf8f127893557623?pvs=4#2dcd22e72a5d447caf82fb8aaf716ce0)

- 읽기(Fetch Instruction, FI): 메모리에서 명령을 가져온다.
- 해석(Decode Instruction, DI): 명령을 해석합니다.
- 실행(Execute Instruction, EI): 명령을 수행합니다.
- 기록(Write Back, WB): 수행한 결과를 기록합니다.

### 명령어 처리 방식

- RISC(Reduced Instruction Set Computer)
    - 컴퓨터 내부적으로 사용하는 명령어 세트를 단순화 시켜서 처리하는 형태의 구조
    - 단순한 명령을 조합해서 하나의 기능을 수행
- CISC(Complex Instruction Set Computer)
    - 하나의 기능에 해당하는 하나의 명령이 있는 개념

### RISC

- 하나의 사이클로 명령어를 처리
- 메모리 Load / Store 명령만 처리하는 방식
- 파이프라이닝, 슈퍼스칼라의 사용이 가능
- 복잡한 컴파일러 구조를 갖고 있음

### CISC

- 여러 사이클로 명령어를 처리합니다.
- 많은 명령어가 메모리를 참조하는 처리 방식입니다.
- 파이프라이닝의 사용이 어렵습니다.
- 복잡한 마이크로 프로그램 구조를 갖고 있습니다.

# 1-2-2. Memory

---

일반적으로 메모라고 하면 기억이라는 개념이다.

컴퓨터에서 말하는 메모리는 기억소자 즉 반도체를 의미

반도체는 특성상 전류를 흐르게 하고 흐르지 않게도 하는 특징이 있어 이를 이용해서 임시적인 내용을 기억하게 만드는 것

## 📍메모리 분류별 특성

기억장소라는 개념에서 확장하면 저장 장소라는 개념의 하드디스크, CD/DVD, USB 저장장치와 같은 보조 기억장치까지 의미한다.

이런 보조 기억장치와 메모리의 차이는 `휘발성`인데, 

**메모리 :** 시스템이 활성화 된 상태에서 그 값을 기억하고 있지만 시스템이 꺼지게 되면(ShutDown) 지워지게 된다.

**보조 기억장치 :** 시스템이 꺼져도 기억하고 있는 값이 휘발되지 않음

저장/읽기 속도 면에서 메모리와 보조 기억장치는 현저하게 차이난다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6e036217-f9b8-4606-92a7-3cd020aeff65/Untitled.png)

CPU와 가장 가까이 있는 레지스터 메모리, 캐시 메모리, 주기억 장치, 보조기억 장치는 각각 그 특성에 차이가 있다.

## 📍메모리 성능

메모리의 속도는 메모리가 CPU와 데이터를 주고 받는 시간을 의미

이를 액세스라 부르며 단위는 ns(nano-second) - 10억분의 1초로써 메모리의 속도의 기준이 된다.

메모리의 성능은 속도가 빠를 수록 성능이 좋다고 말할 수 있다.

- 리프레시 시간
    - 메모리는 일정 시간마다 재충전을 해줘야 하는데, 그렇지 않으면 정보는 사라지게 된다.
    - 이 일정기간을 리프레시 시간이라고 하는데, 이는 메모리에서 한번 읽고 나서 다시 읽을 수 있는 사이 시간을 말한다.
- 메모리 액세스 시간
    - 메모리 액세스 시간은 데이터를 읽어오라는 명령을 받고 데이터를 읽기 시작하기까지의 시간을 말한다.
    - CPU에서 명령어를 처리할 때 명령어가 갖는 주소를 보낸다.
    - 그러면 CPU에 그 주소에 해당하는 값을 가져오게 되는데 걸리는 시간이 액세스 시간이다.
- 사이클 시간
    - 사이클 시간은 메모리 작업이 완료와 동시에 대기 신호를 내놓은 후, 다음 신호를 받을 준비가 되었다는 신호를 주기까지의 시간을 의미한다.
    - 사이클 시간 = 메모리 액세스 시간 + 리프레시 시간

## 📍메모리 종류

메모리 중 주 기억장치 종류로는 RAM과 ROM가, 보조 기억 장치의 종류로는 자기 디스크, 광디스크, 플래시 메모리가 있다.

## 주기억장치

### RAM(Random Access Memory)

- 컴퓨터의 전원이 끊어지면 내용이 휘발되어 보조 저장 장치가 반드시 필요
- RAM의 크기는 프로그램 수행 속도에 영향
- 또한 CPU에서 직접 접근이 가능한 유일한 저장 장치
- 종류에는 SRAM과 DRAM이 있다.
    - SRAM : 리프레쉬가 필요없고 전력 소모가 적으나 비쌈
    - DRAM : 리프레쉬가 필요하고 SRAM보다 저가로 많이 사용

### ROM(Read Only Memory)

- 대부분 읽을 수 있는 장치로 구성되어 있으며 전원이 끊겨도 내용이 보존된다.

## 보조기억 장치

### 자기 디스크

- 원판 표면의 철 입자 방양(N/S극)으로 0과 1을 표현
- 디스크 드라이브는 자기 디스크로부터 데이터를 읽는 주변 장치
- 자기 디스크에는 플로피 디스크(FDD)와 하드디스크(HDD)가 존재

### 광 디스크

- 광디스크(optical disc, OD)는 빛의 반사를 이용해 자료를 읽어내는 저장 매체
- 1세대인 CD부터 시작해 2세대 DVD를 거쳐 3세대인 블루레이 디스크까지 존재(차세대 디스크: 테라디스, HVD)

## 📍캐시 메모리(Cache Memory)

캐시메모리는 CPU 내 또는 외에 존재하는 메모리로, 메인 메모리와 CPU간의 데이터 속도 향상을 위한 중간 버퍼(완충기) 역할을 한다.

여기서 ‘Cache’라는 의미는 보관이 저장의 의미를 갖고 있다.

캐시 메모리는 이러한 역할을 하는 물리적 장치를 말한다.

- CPU와 메인 메모리 사이에 존재한다고 말할 수 있는데, CPU내에 존재할 수도 있고 역할이나 성능에 따라서는 CPU 밖에 존재할 수도 있다.

특히 빠른 CPU의 처리속도와 상대적으로 느린 메인 메모리에서의 속도의 차이를 극복하는 완충 역할을 수행

→ CPU는 빠르게 일을 진행하지만, 메인 메모리가 데이터를 가져오는게 느려서 캐시 메모리가 중간에 미리 CPU에 전달될 데이터를 들고 서있는 형태

## 📍캐시 메모리의 성능 결정 요소

캐시 메모리는 메인 메모리의 일정 블록 사이즈의 데이터를 담아 두었다가 cpu에 워드 사이즈 만큼의 데이터를 전송

이때 이 사이즈들이 캐시의 성능에 영향을 미치게 되는데 블록 사이즈나 워드 사이즈가 상대적으로 크다면 그만큼 Cache의 `Hit Ratio`율이 높아지기 때문

<aside>
💡 ***Hit Ratio란?**
이러한 원하는 데이터가 있을 수도 있고 없을 수도 있는데, 이때 원하는 데이터가 캐시에 있을 확률*

</aside>

CPU가 필요한 데이터가 캐시 메모리 내에 들어와 있으면 `Cache Hit`라 하고 접근하고자 하는 데이터가 없을 경우를 `Cache Miss` 라고 한다.

| 요소 | 내용 |
| --- | --- |
| Cache 크기 | Cache Memory의 Size의 크기가 크면 Hit Ratio율과 반비례 관계 |
| 인출 방식 (Fetch Algorithm) | 요구 인출(Demand Fetch): 필요 시 요구하여 인출하는 방식
선 인출(Pre-Fetch): 예상되는 데이터를 미리 인출하는 방식 |
| 쓰기 정책 (Write Policy) | Write-Through: 주기억 장치와 캐시에 동시에 쓰는 방식. Cache와 메모리의 내용이 항상 일치하며 구성 방법이 단순하다.
Write-Back: 데이터 변경만 캐시에 기록하는 방식. 구성방법이 복잡하다. |
| 교체(Replace) 알고리즘 | Cache Miss 발생시 기존 메모리와 교체하는 방식.
FIFO, LRU, LFU, Random, Optimal Belady’s MIN(향후 가장
참조 되지 않을 블록을 교체) 등이 있다. |
| 사상(Mapping) 기법 | 주기억장치의 블록을 적재할 캐시 내의 위치를 지정하는 방법
직접 매핑(direct mapping), 어소시에이티브 매핑(associative mapping), 셋 어소시에이티브 매핑(set associative mapping) 등이 있다. |

표와 같이 캐시 메모리의 성능 결정 요소에는 캐시의 크기 뿐 아니라 다양한 요소들이 관여하고 있다.

# 2. 운영체제

---

컴퓨터나 스마트폰의 기기 그 자체(하드웨어)는 스스로 할 수 있는 일이 없다.

하드웨어의 설계를 바탕으로 하드웨어에게 일을 시켜야만 그 의미가 있다.

하드웨어에게 일을 시키는 주체가 바로 운영체제이다.

# 2-1. 운영체제(OS)

---

## 📍개념

폰 노이만이 제시한 컴퓨터 모델에 따르면 컴퓨터 시스템은 크게 CPU, 메모리, 디스크로 구성되있다고 볼 수 있다. 

이 각각의 하드웨어를 연결했다고 해서 우리가 원하는 프로그램을 수행할 수 있는 것은 아니다.

하드웨어는 단지 그 하드웨어의 특정 기능을 수행할 뿐인데, 이 컴퓨터라는 하드웨어 상에 프로그램들이 동작되려면 이 하드웨어들과 적절하게 데이터를 주고 받으며 논리적인 일들을 해야만한다.

***그 하드웨어에게 일을 시키는 주체가 바로 운영체제이다.***

## 📍목적 및 기능

운영체제의 목적은 처리 능력 향상, 사용 가능도 향상, 신뢰도 향상, 반환 시간 단축 등에 있다.

- 프로세서, 기억장치, 입출력 장치, 파일 및 정보 등의 자원을 관리
- 자원을 효율적으로 관리하기 위해 자원의 스케줄링 기능을 제공(스케줄링이란 어떤 자원을 누가, 언제, 어떤 방식으로 사용할지를 결정해주는 것)
- 사용자와 시스템 간의 편리한 인터페이스를 제공
- 시스템의 각종 하드웨어와 네트워크를 관리하고 제어

## 시스템 자원 관리

운영 체제가 없다면, 응용 프로그램이 실행될 수 없다. 

응용 프로그램은 컴퓨터를 이용해 다양한 작업을 하는 것이 목적이고, 운영체제는 응용 프로그램이 하드웨어에게 일을 시킬 수 있도록 도와준다.

하드웨어를 구성하는 일을 하는 CPU, 자료를 저장하는 RAM, 디스크 등의 시스템 자원을 관리하는 주체가 바로 운영체제이다.

- 프로세스 관리(CPU)
- 메모리 관리
- I/O(입출력) 관리(디스크, 네트워크 등)

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f41fa661-b9bb-4e40-b05c-e7543ac8b76f/Untitled.png)

## 📍응용 프로그램 관리

모든 응용프로그램이 시스템의 자원을 마음대로 사용한다면, 해커에 의한 공격에 무방한 상태가 된다.

악의적인 목적을 가진 프로그램이 디스크의 모든 민감한 정보에 접근하거나, 내 스마트폰의 특정 앱이 카메라를 아무때나 실행해서 촬영한다고 생각하면 매우 끔찍하다.

그러므로 응용프로그램은 권한에 대한 관리가 필요하다.

또한 여러 사람이 하나의 기기를 사용하는 경우에는 사용자를 관리하는 일도 매우 중요하다.

<aside>
✅ 응용 프로그램이 실행되고, 시스템 자원을 사용할 수 있도록 권한과 사용자를 관리한다.

</aside>

## 응용 프로그램 개념

: 운영체제를 통해 컴퓨터에게 일을 시키는 것

컴퓨터를 일을 시키려면, 컴퓨터를 조작할 수 있는 권한을 운영체제로부터 부여 받아야 한다.

권한을 부여 받고 난 후에는, 운영체제가 제공하는 기능을 이용할 수 있다.

응용 프로그램이 운영체제와 소통하기 위해서는, 운영체제가 응용 프로그램을 위해 인터페이스(API)를 제공해야 한다.

응용 프로그램이 시스템 자원을 사용할 수 있도록, 운영체제 차원에서 다양한 함수를 제공하는 것을 시스템 콜이라고 부른다.

응용프로그램 역시 운영체제가 프린터 사용을 허가해 주지 않는다면 사용할 수 없다.

워드프로세서 프로그램이 프린터를 사용해 인쇄하기 위해서는, 워드 프로세서의 프로그램은 운영체제로부터 프린터 사용에 대한 권한을 부여 받아야 한다.

응용프로그램이 프린터 사용에 대한 권한을 획득한 후에는 프린터를 사용할 때 필요한 API를 호출해야 한다.

이 API는 시스템 콜로 이뤄져 있다.

# 2-2. 프로세스

---

## 📍개념

- 프로그램이 실행 중인 상태로 특정 메모리 공간에 프로그램의 코드가 적재되고 CPU가 해당 명령어를 하나씩 수행하고 있는 상태
- 운영 체제에서는 프로세스를 사용하여 프로그램을 수행하게 되는데 실행중인 하나의 애플리케이션을 프로세스라고 부른다.

사용자가 애플리케이션을 실행하면, 운영체제로부터 실행에 필요한 메모리를 할당 받아 애플리케이션의 코드를 실행한다.

이때 실행되는 애플리케이션을 프로세스라고 부른다.

예를 들어 크롬 브라우저를 두 개 실행하면, 두 개의 프로세스가 생성된다.

이렇게 하나의 애플리케이션은 여러 프로세스(다중 프로세스)를 만들기도 한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/3aad8735-c907-4824-b8b3-e2f3678f48ee/Untitled.png)

## 📍구성 요소

프로세스의 구조체에는 프로세스마다 독립적으로 관리해야 하는 유저 메모리 영역이나 프로세스가 사용하는 가종 객체들의 포인터를 관리하는 핸들 테이블을 가지고 있다.

1. 유저 메모리 영역 관리(Virtual Address Descriptors)
    - 프로세스 별로 독립된 영역을 가지게 되는 곳은 유저 메모리 공간
    - 커널 메모리 공간의 경우 모든 프로세스가 공유하여 사용
    - 프로세스 별로 독립적인 유저 메모리 영역을 관리하기 위해서 VAD(Virtual Address Descriptors)라는 관리 테이블이 존재
2. 핸들 테이블
    - 핸들 테이블은 프로세스에서 사용하는 모든 핸들에 대한 커널 객체 포인터 정보를 배열 형태로 가지고 있는 공간
    - 프로세스가 종료하게 될 때 이 테이블의 정보를 참고하여 이 프로세서에서 사용하고 있는 모든 커널 객체를 자동으로 반환
3. 독립적인 메모리 공간
    - 프로세스 단위로 관리되는 자원 중 가장 중요한 구별점은 가상 메모리
    - 페이징 기법을 이용하여 프로세스 마다 별도의 고유한 메모리를 사용(운영체제가 윈도우인 경우)

## 📍특징

- 자원 소유의 단위
    - 각각의 프로세스는 자신의 실행 이미지 로드와 실행에 필요한 추가적인 메모리 공간을 가지고 있어야 함
    - 이것은 각 프로세스마다 구별되어야 하며 해당 프로세스가 접근하고자 하는 파일, I/O 장치들에 대해서 또한 프로세스 단위로 할당 받아 관리되어야 한다.
- 디스패칭의 단위
    - 프로세스는 하나의 프로그램이 운영체제로부터 CPU의 자원을 일정 기간 동안 할당 받아 명령어를 실행하는 것
    - 운영체제는 여러 개의 프로세스가 병렬적으로 실행되게 하기 위해서 CPU의 사용 시간을 각각의 프로세스에 골고루 나눠 줘야 한다.
    - **스레드(Thread)** : 프로세스 내에서 실행되는 흐름의 단위를 의미하며, 운영체제로부터 자원을 할당 받는 작업의 단위이다.
        - 스레드는 프로세스 내에서 실제 작업을 수행하는 주체이다.
        - 모든 프로세스는 하나 이상의 스레드가 존재하여 작업을 수행한다.

## 📍프로세스 상태

- 실행 : 프로세스가 프로세서를 차지하여 서비스를 받고 있는 상태를 말함
- 준비 : 실행 준비
- 대기 : CPU의 사용이 아니라 입출력의 사건을 기다리는 상태

<aside>
❓ 프로세서 vs 프로세스
프로세서와 프로세스는 엄밀히 말하면 다른 존재이다.

</aside>

### 프로세서(processor)

- 하드웨어적 측면 : 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛으로, 중앙처리장치(CPU)를 의미하며 적어도 하나 이상의 ALU와 레지스터를 내장하고 있다.
- 소프트웨어적인 측면 : 데이터 포멧을 변환하는 역할을 수행하는 데이터 처리 시스템을 의미, 워드프로세서나 컴파일러 등이 여기 속함

### 프로세스(process)

- 프로세스는 특정 목적을 수행하기 위해 나열된 작업의 목록
- 메모리에 적재되어 프로세서에 의해 실행중인 프로그램을 말함

# 2-3. 스레드(Thread)

---

## 📍개념

스레드는 명령어가 CPU를 통해서 수행되는 객체의 단위

하나의 프로세스 내에는 반드시 1개 이상의 스레드가 존재하며, 이러한 스레드는 같은 프로세스에 있는 자원가 상태를 공유한다.

![프로세스 내에 스레드가 존재하므로 서로 자원가 상태 공유 가능](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/28533c7e-f25f-4bc3-a440-7ca0e0e407f3/Untitled.png)

프로세스 내에 스레드가 존재하므로 서로 자원가 상태 공유 가능

같은 프로세스 내에 있는 스레드는 같은 주소 공간에 존재하게 되며 동일한 데이터에 접근할 수 있다.

또한 하나의 스레드가 수정한 메모리는 같은 메모리를 참조하는 스레드에 영향을 미치게 된다.

예를 들어 하나의 스레드에서 오픈한 파일을 다른 스레드가 사용할 수 있다. 

프로세스가 종료되면 그 프로세스에 속해있던 스레드도 함께 종료됨

## 📍필요한 이유

- 하나의 프로세스 안에서 여러개의 루틴을 동시에 수행해서 수행 능력을 향상하기 위해
- 독립적으로 수행하여 처리하기 위해

<aside>
✅ 여러개의 작업 단위로 구성된 프로그램에서 요청을 동시에 처리하기 위해서 사용한다.

</aside>

e.g. 워드 프로세서에서 사용자로부터 키보드 입력 받거나, 그래픽이나 UI를 그리고 문법 오류를 체크하는 등 여러 요청을 동시에 처리할 때 사용한다.

## 📍구성요소

- 가상 CPU : 인터프리터, 컴파일러에 의해 내부적으로 처리되는 가상 코드
- 수행 코드 : Thread Class에 구현되어 있는 `run()`메서드 코드이다.
- 처리 데이터 : Thread에서 처리하는 데이터

## 📍특징

- 프로세스 내에서 실행되는 흐름의 단위, 하나의 스레드는 시작해서 종료할 때까지 한번에 하나씩 명령을 수행
- 각 스레드마다 call back(실행중인 서브루틴을 저장하는 자료구조)이 존재하며, 나머지 Code, Data, Heap 영역은 스레드 끼리 공유, 반면 프로세스는 다른 프로세스의 메모리에 직접 접근할 수 없다.
- 스레드는 다른 스레드와 독립적으로 동작하기 때문에 두 개 이상의 스레드가 동작되는 경우, 두 개 이상의 스레드의 실행 및 종료 순서는 예측 할 수 없다.

# 2-3-1. 싱글 스레드와 멀티 스레드

---

![프로세스와 싱글스레드, 멀티스레드 예시](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/b67a9f64-8287-4563-94d7-f857fd622957/Untitled.png)

프로세스와 싱글스레드, 멀티스레드 예시

## 📍싱글 스레드(Single-Thread)

- 프로세스가 단일 스레드로 동작하는 방식으로 일련의 처리를 단일 스레드만으로 직렬 처리하는 프로그래밍 방법
- 하나의 레지스터, 스택으로 표현한다.
- 자바스크립트는 가장 대표적인 싱글 스레드 언어

### 장점

- 자원 접근에 대한 동기화를 신경쓰지 않아도 된다.
- 여러개의 스레드가 프로세스의 자원을 공유할 경우, 각 스레드가 원하는 결과를 얻게 하려면 공용 자원에 대한 접근을 제어해야 한다. 
→ 모든 스레드가 일정 자원을 동시 접근하거나, 똑같은 작업을 실행하려는 경우, 에러가 발생 or 원하는 값 안나옴
- 자원 접근에 대한 동기화를 신경쓰지 않아도 되므로 문맥 교환(context switch) 작업 또한 요구하지 않는다.
    - 문맥 교환: 여러개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업으로 많은 비용이 필요
- 프로그래밍 난이도가 쉽고, CPU 메모리를 적게 사용

### 단점

- 여러개의 CPU를 활용하지 못한다.
    - 싱글 스레드는 하나의 물리적 코어 밖에 사용하지 못해 멀티 코어 머신에서 CPU를 최적화할 수 없다.
    - 최적화를 위해선 Cluster 모듈을 이용하여 여러 프로세스를 사용할 수 있다.
    - 하지만 앞서 프로세스끼리의 자원 공유는 어렵기 때문에 Redis와 같은 부가 인프라가 필요
- 연산량이 많은 작업을 하는 경우, 그 작업이 완료되어야 다른 작업을 수행할 수 있다.
- 싱글 스레드 모델은 에러 처리를 못하는 경우 그대로 정지한다.
    - 멀티 스레드 모델은 에러 발생시 새로운 스레드를 생성하여 극복 가능

## 📍멀티 스레드(Multi-Thread)

- 하나의 프로세스 내에서 둘이상의 스레드가 동시에 작업을 수행하는 것
- 멀티 프로세스는 여러 개의 CPU를 사용하여 여러 프로세스를 동시에 수행하는 것
- 시스템 자원의 활용 극대화 및 처리량 증대할 수 있어 단일 프로세스 시스템의 효율성을 높일 수 있다.

### 장점

- 작업을 분리해서 수행하므로 실시간으로 사용자에게 응답 가능 (싱글 스레드인 경우, 작업이 끝나기 전까지 사용자에게 응답 🙅🏻‍♂️)
- 한 프로세스를 여러 프로세서에서 수행 가능(싱글 스레드인 경우, 한 프로세스는 오직 한 프로세서에서만 수행 가능)

### 문제점

- 주의 깊은 설계가 필요하며, 디버깅이 까다롭다.
- 단일 프로세스 시스템의 경우 효과를 기대하기 어려우며 다른 프로세스에서 스레드를 제어할 수 없다.(즉, 프로세스 밖에서 스레드 각각 제어 불가)
- 멀티 스레드의 경우 자원 공유의 문제가 발생 → 하나의 스레드에 문제가 발생하면 전체 프로세스 영향
- 문맥 교환 작업을 필요
    - 문맥 교환(Context Switching): CPU에서 여러 프로세스를 돌아가면서 작업을 처리
    - 문맥 교환이란 다른 태스크(프로세스, 스레드)가 작업을 시작할 수 있도록 이미 실행 중인 태스크(프로세스, 스레드)를 멈추는 것을 말함

### 관련 키워드

- 데드락(Deadlock, 교착상태)

- 뮤텍스(Mutex), 세마포어(Semaphore)

# 2-3-2. 동시성과 병렬성의 차이

---

![싱글 코어와 멀티코어 예시](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/622dad07-7512-4005-be88-12e77ef703db/Untitled.png)

싱글 코어와 멀티코어 예시

- 동시에 돌릴 수 있는 스레드 수는 컴퓨터에 있는 코어 개수로 제한된다.
- 운영체제(또는 가상 머신)는 각 스레드를 시간에 따라 분할하여, 여러 스레드가 일정 시간마다 돌아가면서 실행되도록 한다.
- 이런 방식을 **동시 분할**이라고 한다.
    - Concurrency(동시성, 병행성) : 여러 개의 스레드가 시분할 방식으로 동시에 수행되는 것처럼 착각을 불러 일으킴
    - Parallelism(병렬성) : 멀티코어 환경에서 여러개의 스레드가 실제로 동시 수행됨

# 3. 문자열과 그래픽

---

컴퓨터 과학은 이론적인 부분과 실용적인 부분으로 나뉘어져 있으나 컴퓨터가 받아 들이는 기본적인 언어는 프로그래밍 언어이고, 프로그래밍 언어로 다룰 수 있는 가장 기본적인 소스인 **문자열**과 **그래픽**에 대해 학습한다.

# 3-1. 문자열

---

## 문자열

2010년도 이후, 우리는 유니코드라고 불리는 인코딩 방식이 통일된 시대를 살아가고 있다. 

문자열을 다루는 디테일한 방식에 대해 전부 알필요는 없지만, 프로그래밍 언어마다 문자열을 다루는 자료형의 차이를 이해하기 위해 문자열을 다루는 기본적인 방식은 알고 있어야 한다.

## 유니코드

- 유니코드(Unicode)는 유니코드 협회(Unicode Consortium)가 제정하는 전 세계의 모든 문자를 컴퓨터에서 일관되게 표현하고 다룰 수 있도록 설계된 산업 표준이다.
- 이 표준에는 ISO 10646 문자 집합, 문자 인코딩, 문자 정보 데이터베이스, 문자를 다루기 위한 알고리즘 등을 포함하고 있다.
- 기본적으로 유니코드의 목적은 현존하는 인코딩 방법을 모두 유니코드로 교체하는 것이다.

<aside>
💡 ***인코딩(부호화)란?**
인코딩은 문자나 기호를 컴퓨터가 이용할 수 있는 신호로 만드는 것이다.
이 신호를 입력하는 인코딩과 문자를 해독하는 디코딩을 하기 위해서는 미리 정해진 기준을 바탕으로 처리되어야 한다.
이 기준을 문자열 세트 또는 문자셋(charset)이라고 하며, 이 문자셋의 국제 표준이 유니코드입니다.*

</aside>

## ASCII

- 영문 알파벳을 사용하는 대표적인 문자 인코딩으로 7비트로 모든 영어 알파벳을 표현할 수 있다.
- 52개의 영문 알파벳 대소문자와, 10개의 숫자, 32개의 특수문자, 그리고 하나의 공백문자를 포함한다.
- 유니코드는 ASCII를 확장한 형태이다.

## utf-8과 utf-16의 차이

인코딩 방식의 차이이다.

utf-8 : Universal Coded Character Set + Transformaion Format - 8 - bit의 약자로, utf - 뒤에 등장하는 숫자는 bit이다.

### utf-8 특징

1. 가변 길이 인코딩
    
    utf-8은 1byte에서 4byte까지의 가변 길이를 갖는 인코딩 방식이다.
    
    네트워크를 통해 전송되는 텍스트는 주로 utf-8로 인코딩 된다.
    
    사용된 문자에 따라 더 작은 크기의 문자열을 표현할 수 있기 때문(ASCII 문자는 1byte로 표현 가능한 것처럼)
    
2. byte 순서가 고정됨
    
    utf-16에 비해 바이트 순서를 따지지 않고, 순서가 정해져 있다.
    

### utf-16 특징

코드 그대로 바이트로 표현 가능, 바이트 순서가 다양하다.

utf-16은 유니코드 대부분을 16bits로 표현 → 그외 32bit(4bytes)로 표현함

# 3-2. 그래픽

---

비트맵과 백터는 디지털 이미지의 종류이다.

디지털 이미지, 또는 이미지라고 불리는 용어는 디지털 카메라를 이용하여 현실세계의 사물을 촬영하거나 스캐너를 이용하여 사진이나 그림을 디지털 형태로 받아들인 것을 가리킨다.

서로 상반된 방식으로 이미지를 표현하기 때문에 비트맵과 백터는 큰 차이가 있다.

## 비트맵

웹 상에서 디지털 이미지를 저장하는데 가장 많이 쓰이는 이미지 파일 포맷 형식

일반적으로 래스터 그래픽(점 방식)이라고 한다.

이미지의 각 점들을 격자형의 픽셀 단위로 구성되며, 한 지역을 차지하는 셀은 위치에 따라 다른 값을 갖는다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8398e644-6f2c-4377-a995-acc771ef2330/Untitled.png)

이런 비트맵은 사각의 픽셀 형태로 모여 있기 때문에 확대를 하면 ‘계단현상’ 또는 깨짐이 발생하며, 경계가 뚜렷하지 않다는 특징이있다.

이런식으로 픽셀 단위로 표현하는 방식은 컴퓨터에게 부담을 덜 주는 구조로 되어 있다.

또한 픽셀 하나 당 색상값을 갖고 있다.

따라서 이미지의 사이즈가 커질수록 용량 또한 무거워진다는 특징이 있다.

## 백터(Vector)

비트맵과는 완전히 다른 방식으로 이미지를 표현한다.

비트맵이 격자형의 픽셀 단위로 이미지를 구성한다면 벡터는 이미지르 수학적인 공식으로 표현한다.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6cd99132-6518-42be-8ca4-e65b96639511/Untitled.png)

- 점과 점을 연결해 선을 표현하고 선과 선을 연결해 면을 표현하는 식의 수학적 원리로 그림을 그리기 때문에 비트맵과는 달리 아무리 확대를 해도 ‘계단 현상’ 또는 깨짐이 발생❌
- 비트맵에 비해 컴퓨터에게 부담을 가하는 방식 → 줄로 도형, 글자 등을 그리는 작업에 사용
- 수학적인 연산으로 만들어진 이미지이기 때문에 사이즈를 키워도 용량에는 변화 ❌

## 비트맵(래스터)과 벡터 이미지의 차이점

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/f943af22-a4db-4517-8cb6-bab4ae52b959/Untitled.png)

|  | 비트맵(래스터) | 백터 |
| --- | --- | --- |
| 기반 기술 | 픽셀 기반 | 수학적으로 계산된 shape기반 |
| 특징 | 사진과 같이 색상의 조합이 다양한 이미지에 적합 | 로고, 일러스트와 같이 제품에 적용되는 이미지에 적합 |
| 확대 | 확대에 적합하지 않음, 보다 큰 사이즈의 이미지가 필요할 때 사용하려는 크기 이상으로 생성하거나 스캔해야 함 | 품질 저하 없이 모든 크기로 확대 가능, 해상도 영향 ❌ |
| 크기(dimension)에 따른 파일 용량(file size) | 큰 크기의 이미지는, 큰 파일 사이즈를 가짐 | 큰 크기의 백터 그래픽은 작은 파일 사이즈를 유지🙆🏻‍♂️ |
| 상호 변환 | 이미지의 복잡도에 따라 벡터로 변환하는 것에 오랜 시간이 걸림 | 쉽게 래스터 이미지로 변환 🙆🏻‍♂️ |
| 대표적인 파일 포맷 | jpg, gif, png, bmp, psd | svg, ai |
| 웹에서의 사용성 | jpg, gif, png 등이 널리 쓰임 | svg 포맷은 현대의 브라우저에서 대부분 지원 |

# 4. 가바지 컬렉션

---

## 📍개념

: **프로그램에서 더 이상 사용하지 않는 메모리를 자동으로 정리하는 것**

이 기능을 가진 언어는 자바, C#, JS 등이 있다.

C언어 같은 저수준 언어에서는 메모리 관리를 위해 `malloc()`과 `free()`를 사용해 개발자가 스스로 메모리를 할당하고 해제해야 한다.

그러나 JavaScript는 C언어와 반대로 고수준 언어로서, 객체가 생성되었을 때 자동으로 메모리를 할당하고 필요하지 않다면 자동으로 해제하는 가비지 컬렉션이 내장되어 있다.

<aside>
💡 ***고수준 언어 vs 저수준 언어**
저수준 언어는 보다 **기계에게 친화적인** 언어로 레지스터 및 메모리와 직접 상호작용 가능하기 때문에, 전반적으로 빠르게 실행되는 응용프로그램을 빌드하는데 사용
고수준 언어는 **인간 친화적인** 언어로, 인간이 이해하기 쉽고 다양한 작업을 수행하는 프로그램을 개발시 사용*

</aside>

개발자가 직접 메모리를 할당하고 해제해야 하는 부분을 가비지 컬렉션이 도와주기 때문에, 개발자가 메모리 관리에 대해 고민할 필요가 없다는 잘못된 인상을 받을 수 있다.

가비지 컬렉션이 어떻게 동작하는지, 자바스크립트가 어떻게 메모리를 관리하는지 알아야 훗날 개발한 앱의 속도 저하, 예기치 못한 종료, 느린 응답 속도와 같은 문제들이 왜 일어나는지 알 수 있다.*(~~이건 정말 궁금하고 배워두면 좋겠다.)~~*

## 📍메모리 생존 주기

메모리 생존 주기는 그 어떤 프로그래밍 언어에 관계없이 비슷하다.

1. 필요할 때 개발자가 할당
2. 할당된 메모리를 사용한다. (Read and Write)
3. 메모리가 더이상 필요하지 않으면 해제

2번의 할당된 메모리를 사용하는 것은 모든 언어에서 명시적으로 사용되는 부분이다. 

자바스크립트로 예를 들자면 개발자가 변수를 선언해 값을 할당하여 사용하는 부분이다.

그러나 1번과 3번은 C언어와 같은 기계친화적인 저수준 언어에서는 명시적이고, 자바스크립트 같은 고수준 언어에서는 암묵적으로 작동한다.

### 메모리 할당

자바스클비트는 프로그래머 대신, 값을 선언할 때 자동으로 메모리를 할당 해준다.

```jsx
let arr = [1, 2, 3, 4]
```

변수 선언하고 배열 할당하여 안에 요소를 집어 넣을 때, 그 배열을 담을 메모리의 크기를 고려해본적이 없다.

이 부분을 자바스크립트가 배열과 배열에 담긴 값들을 위한 메모리 크기 할당을 알아서 진행했기 때문이다.~~*(고맙다)*~~

이 부분은 정수, 문자열, 함수, 객체 모든 부분에서 자동적으로 일어난다.

### 할당된 메모리 사용(값 사용)

기본적으로 할당된 메모리를 읽고 쓰는 것을 의미한다.

변수나 객체 속성의 값을 읽고 쓰거나, 함수 호출 시에 함수에 인수를 전달하여 수행하는 방식으로 일어난다.

### 메모리 해제

할당된 메모리가 더이상 필요 없다면 해제를 해야 앱의 성능을 저하시키지 않는다.

이 부분에서, 저수준 언어는 개발자가 직접 결정하고 해제하는 방식을 사용한다.

개발자가 직접 관여하기 때문에 개발자의 제어 정도가 굉장히 높다.

그러나 고수준 언어는 앞서 말했듯 가비지 컬렉션이 내장된 상태이다.

가비지 컬렉션의 목적은 메모리 할당을 추적하고, 할당된 메모리 블록이 더이상 필요하지 않게 되었는지를 스스로 판단하여 필요하지 않다고 판단할 경우 메모리를 해제한다.

하지만 언어 스스로 메모리가 여전히 필요한지 필요하지 않은지 판단하는 것은 비결정적인 영역이다.

그래서 고수준언어에 내장된 가비지 컬렉터들은 제한적인 해결책을 구현한다.~~(이제 AI를 이용한 언어가 새로나올듯..)~~

## 📍대표적인 가비지 컬렉션의 방법

가바지 컬렉션 알고리즘은 레퍼런스 카운팅, 트레이싱 이 2가지 알고리즘이 가장 유명하다.

> 이 두가지 알고리즘이 의존하고 있는 개념
> 
- 참조(reference)
    
    명시적이든, 암묵적이든 관계없이 메모리 관리 관점에서 어떤 객체가 다른 객체에 접근할 수 있다면 다른 객체를 참조한다고 말한다.
    
    예를 들어 자바스크립트 객체는 자신의 프로토타입에 대해 암묵적인 참조를 갖고 있고, 자신의 속성 값에 대한 명시적 참조도 가지고 있다.
    
    객체를 참조하는 것에 대해, 객체란 협의적 개념으로 일반적인 자바스크립트 객체를 의미하지만 더 넓은 개념으로 함수 스코프나 글로벌 렉시컬 스코프 까지 포함한다는 것을 알아두자~~*(왜이렇게 어려운 단어로 해놓은거람..)*~~
    
- 렉시컬 스코핑(lexical scoping)
    
    변수이름이 중첩된 함수에서 해석되는 방식을 정의하는 것으로, 중첩되어 있는 더 안쪽의 함수는 부모 함수가 값을 반환한 다음에도 부모 함수의 스코프를 포함하고 있다.
    

### 레퍼런스 카운팅(참조 횟수 계산)

한 객체를 참조하는 변수의 수를 추적하는 방법으로 가장 단순한 형태의 가비지 컬렉션 알고리즘이다.

객체를 참조하는 변수는 처음에는 특정 메모리에 대해 레퍼런스가 하나뿐이지만, 변수의 레퍼런스가 복사될 때마다 레퍼런스 카운트가 늘어난다.

객체를 참조하고 있던 변수의 값이 바뀌거나, 변수 스코프를 벗어나면 레퍼런스 카운트는 줄어든다.

레퍼런스 카운트가 0이 되면, 그 객체와 관련한 메모리는 비울 수 있다.

레퍼런스 카운트가 0이된다는 말은 아무도 그 객체에 대한 레퍼런스를 가지고 있지 않다는 말과 같다.

이 방식은 순환 참조로 인한 문제가 생길 가능성이 높다.

```jsx
function reference() {
	var obj1 = {};
  var obj2 = {};
  obj1.p = obj2; 
  obj2.p = obj1; 
}
reference();
```

위 코드에서는 두 객체가 생성되고 서로를 참조하고 있는 형태이기 때문에 순환 참조가 발생한다.

이 객체들은 함수 호출 뒤에는 스코프를 벗어나게 되므로 실질적으로 쓸모가 없게 된다.

그래서 이들이 차지하던 메모리는 반환될 수 있지만, 레퍼런스 카운팅 알고리즘에서는 두 객체가 적어도 한 번은 참조한 것으로 간주되기 떄문에 둘 다 가비지 컬렉션이 될 수 없게 된다.

### 트레이싱(mark and sweep)

한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep 방법이다.

객체에 in-use flag를 두고, 사이클마다 메모리 관리자가 모든 객체를 추적해서 사용 중인지 아닌지를 표시한다.

그 후 표시되지 않은 객체를 삭제(sweep)하는 단계를 통해 메모리를 해제한다.

현재 대부분의 가비지 컬렉션이 mark and sweep 알고리즘을 이용한 가비지 컬렉터를 장착하고 있다.

mark and sweep 알고리즘은 객체가 필요한지 결정하기 위해 해당 객체에 닿을 수 있는지(reachable)을 판단하고 밑의 3단계를 거친다.

1. 루트 : 일반적으로 루트는 코드에서 참조되는 전역 변수이다.
    
    예를 들어 자바스크립트에서 루트로 동작할 수 있는 전역 변수는 `window` 객체이다. Node.js에서 이와 동일한 객체는 `global`이다.
    
    가비지 컬렉터는 모든 루트의 완전한 목록을 만들어낸다.
    
2. 그런 다음 모든 루트와 그 자식들을 검사해서 활성화 여부를 표시한다.(활성상태인 경우 가비지가 아니다.) → 루트가 닿을 수 없는 것들은 가비지로 표시
3. 마지막으로 가비지컬렉터는 활성으로 표시되지 않은 모든 메모리를 OS에 반환한다.

## 📍메모리 누수

Garbage collected 언어에서 메모리 누수의 주요 원인은 예상치 못한 참조이다.

예상치 못한 참조는 개발자는 더이상 사용되지 않을 것이라 생각했지만, 어떠한 이유로 활성화 상태인 루트 트리 안에 존재하는 메모리 조각들이다.

자바스크립트에서 예상치 못한 참조는 더이상 사용되지 않지만 코드 상 어딘가에 유지되어 해제되지 못한 변수이다.

그래서 자바스크립트에서 발생할 수 있는 일반적인 메모리 누수 형태들을 이해하기 위해서는 흔히 까먹기 쉬운 참조들을 먼저 알 필요가 있다.

- 메모리 누수의 형태
    - 우발적으로 생성된 전역 변수
    - DOM 외부에서의 참조
    - 클로저의 잘못된 사용

프로그래밍 언어의 메모리 관리 시스템이 특정 메모리가 실제 사용중인지 미사용중인지 완벽히 구분해내는 것은 사실상 불가능에 가깝다.

오직 그 코드를 작성한 개발자들만이 해당 메모리 조각을 운영체제로 반환시킬 수 있는지 여부를 명확히 알 수 있기 때문에 해당 부분들을 잘 확인하여 메모리 누수가 일어나는 부분을 막을 줄 알아야 한다.